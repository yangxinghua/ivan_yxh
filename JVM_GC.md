---
title: Java内存区域与垃圾回收机制
date: 2016-12-21
tag: Java
---

# 本文的产生
对程序员而言，Java相较于C++友好的一点就是不需要我们去自己分配与回收内存，这些工作，JVM帮我们完成了。然而，作为一个有追求的程序员，难道你不想知道JVM是怎么实现的吗？关于JVM的介绍，个人认为《深入理解Java虚拟机--JVM高级特性与最佳实践》是一本很好的书。本文也是对该书中的*垃圾回收机制*介绍的理解与总结。如果有理解错误的地方，欢迎指正。

## 内存划分
* 程序计数器：当前线程操作的行号指示器，线程私有。
* 虚拟机栈：局部变量表，操作数栈，动态链接，方法出口。每个方法调用时，会在虚拟机栈中创建一个栈帧，随着方法执行完毕，该栈帧出栈。
* 本地方法栈：以虚拟机栈一致，不过这里是为Native方法服务。
* 堆：存放对象实例，垃圾回收器工作的地方
* 方法区：包括加载的类信息，常量，静态变量，即使编译后的代码。
* 常量池：存放编译期生成的各种字面量和符号引用。

## 哪些是垃圾
要回收，则JVM必须识别出哪些是正在使用对象，哪些是不再使用的对象。以下两种算法可以判定一个对象是否应该回收。
* 引用计数算法
每当有一个地方引用这个对象，它的引用计数就加1。当引用计数为0时，即没有一个地方引用该对象，则认为该对象是可以回收的。这种方法简单高效，但是当两个对象相互引用，没有其他地方再引用它们时，其实它们都是应该被回收却无法回收。所以主流的Java虚拟机没有使用该方法来管理内存。
* 可达性分析算法
通过GC Roots对象向下搜索，所走过的路径上的对象形成引用链，凡是不在引用链的对象都视为可回收对象。这种算法解决了因为相互引用而无法回收的问题。主流虚拟机都是使用此算法来判定对象是否可回收。GC Roots对象包括以下几种：1. 虚拟机栈中引用的对象。 2. 方法区中类静态属性引用的对象。  3. 方法区中常量引用的对象。 4.本地方法栈JNI引用的对象。

## 回收算法
标识出了可回收对象，如何去回收才比较高效
* 标记-清除算法：标记需要被回收的对象，然后进行统一回收。
* 复制算法：将内存分成两块，A内存使用完后，将存活对象复制到B内存，并清理A内存。
* 标记-整理算法：将存活对象移到一端，然后清理另一端。

## 根据不同内存空间采用不同的回收算法
* 新生代
该内存区域的对象特点是较快消亡，适用复制回收算法.

* 老年代
该内存区域的对象特点是存在时间较长，适用标记-整理算法。
